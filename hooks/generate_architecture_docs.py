#!/usr/bin/env python3
"""
Gerador de documenta√ß√£o de arquitetura do projeto.
Cria arquivos markdown com a estrutura e descri√ß√µes dos diret√≥rios.
"""

import os
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Tuple

# Configura√ß√µes
PROJECT_ROOT = Path(__file__).parent.parent.parent
ARCHITECTURE_DIR = PROJECT_ROOT / "architecture"
IGNORE_DIRS = {'.git', '__pycache__', 'node_modules', '.pytest_cache', '.venv', 'venv', '.env'}
IGNORE_FILES = {'.pyc', '.pyo', '.pyd', '.so', '.egg', '.egg-info', '.DS_Store'}

# Descri√ß√µes conhecidas dos diret√≥rios principais
KNOWN_DESCRIPTIONS = {
    "app": "C√≥digo principal da aplica√ß√£o backend",
    "app/aiagent": "Sistema de agentes de IA para atendimento automatizado",
    "app/aiagent/models": "Modelos SQLAlchemy para agentes de IA",
    "app/aiagent/routes": "Endpoints da API para funcionalidades de IA",
    "app/aiagent/schemas": "Schemas Pydantic para valida√ß√£o de dados",
    "app/aiagent/services": "L√≥gica de neg√≥cio dos agentes de IA",
    "app/core": "Funcionalidades centrais e compartilhadas",
    "app/core/config": "Configura√ß√µes e vari√°veis de ambiente",
    "app/core/logging": "Sistema de logging centralizado",
    "app/core/scheduler": "Agendador de tarefas (APScheduler)",
    "app/core/services": "Servi√ßos compartilhados do sistema",
    "app/api": "Configura√ß√£o e roteamento da API",
    "app/auth": "Sistema de autentica√ß√£o e autoriza√ß√£o",
    "app/auth/models": "Modelos de usu√°rio e permiss√µes",
    "app/auth/routes": "Endpoints de autentica√ß√£o",
    "app/auth/services": "L√≥gica de autentica√ß√£o JWT",
    "app/db": "Configura√ß√£o e gerenciamento do banco de dados",
    "app/domain": "Modelos de dom√≠nio e entidades de neg√≥cio",
    "app/domain/models": "Modelos SQLAlchemy do dom√≠nio",
    "app/domain/schemas": "Schemas de valida√ß√£o do dom√≠nio",
    "app/infrastructure": "Camada de infraestrutura e servi√ßos externos",
    "app/integrations": "Integra√ß√µes com servi√ßos externos",
    "app/integrations/wassenger": "Integra√ß√£o com WhatsApp via Wassenger",
    "app/integrations/openai": "Integra√ß√£o com OpenAI GPT",
    "app/integrations/webhooks": "Handlers de webhooks externos",
    "frontend": "Aplica√ß√£o frontend React",
    "scripts": "Scripts utilit√°rios e de manuten√ß√£o",
    "logs": "Arquivos de log da aplica√ß√£o",
    "architecture": "Documenta√ß√£o da arquitetura do projeto",
    "hooks": "Scripts de hooks do Claude Code",
    "alembic": "Migra√ß√µes do banco de dados",
    "documents": "Documenta√ß√£o geral do projeto",
}

# Descri√ß√µes de arquivos comuns
FILE_DESCRIPTIONS = {
    "__init__.py": "Inicializador do m√≥dulo Python",
    "setup.py": "Configura√ß√£o de instala√ß√£o do pacote",
    "requirements.txt": "Depend√™ncias Python do projeto",
    "README.md": "Documenta√ß√£o principal",
    "CHANGELOG.md": "Hist√≥rico de mudan√ßas",
    ".env": "Vari√°veis de ambiente",
    ".gitignore": "Arquivos ignorados pelo Git",
    "docker-compose.yml": "Configura√ß√£o Docker Compose",
    "Dockerfile": "Imagem Docker da aplica√ß√£o",
    "package.json": "Configura√ß√£o e depend√™ncias Node.js",
    "tsconfig.json": "Configura√ß√£o TypeScript",
    # Arquivos espec√≠ficos
    "main.py": "Ponto de entrada da aplica√ß√£o FastAPI",
    "api.py": "Configura√ß√£o central da API",
    "database.py": "Configura√ß√£o de conex√£o com banco de dados",
    "config.py": "Configura√ß√µes gerais da aplica√ß√£o",
    "models.py": "Modelos de dados",
    "schemas.py": "Schemas de valida√ß√£o",
    "routes.py": "Defini√ß√£o de rotas/endpoints",
    "service.py": "L√≥gica de neg√≥cio",
    "utils.py": "Fun√ß√µes utilit√°rias",
}

def should_ignore(path: Path) -> bool:
    """Verifica se o arquivo/diret√≥rio deve ser ignorado."""
    name = path.name
    
    # Ignora diret√≥rios especiais
    if path.is_dir() and name in IGNORE_DIRS:
        return True
    
    # Ignora arquivos por extens√£o
    if path.is_file():
        if any(name.endswith(ext) for ext in IGNORE_FILES):
            return True
    
    return False

def get_tree_structure(directory: Path, prefix: str = "", is_last: bool = True) -> List[str]:
    """Gera estrutura em √°rvore estilo 'tree' command."""
    lines = []
    
    if not directory.exists():
        return lines
    
    # Conectores da √°rvore
    connector = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
    
    # Adiciona o diret√≥rio atual
    if prefix == "":  # Raiz
        lines.append(f"{directory.name}/")
    else:
        lines.append(f"{prefix}{connector}{directory.name}/")
    
    # Prepara o prefixo para os filhos
    if prefix == "":
        child_prefix = ""
    else:
        child_prefix = prefix + ("    " if is_last else "‚îÇ   ")
    
    # Lista e ordena conte√∫do
    try:
        items = sorted(directory.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))
        items = [item for item in items if not should_ignore(item)]
        
        for i, item in enumerate(items):
            is_last_item = i == len(items) - 1
            
            if item.is_dir():
                lines.extend(get_tree_structure(item, child_prefix, is_last_item))
            else:
                connector = "‚îî‚îÄ‚îÄ " if is_last_item else "‚îú‚îÄ‚îÄ "
                lines.append(f"{child_prefix}{connector}{item.name}")
    except PermissionError:
        pass
    
    return lines

def get_file_description(file_path: Path, base_path: Path) -> str:
    """Obt√©m descri√ß√£o de um arquivo baseado em seu nome e localiza√ß√£o."""
    name = file_path.name
    relative_path = file_path.relative_to(base_path)
    
    # Verifica descri√ß√µes conhecidas
    if name in FILE_DESCRIPTIONS:
        return FILE_DESCRIPTIONS[name]
    
    # Descri√ß√µes baseadas em padr√µes
    if name.endswith("_service.py"):
        return f"Servi√ßo de {name.replace('_service.py', '').replace('_', ' ')}"
    elif name.endswith("_routes.py"):
        return f"Rotas API para {name.replace('_routes.py', '').replace('_', ' ')}"
    elif name.endswith("_model.py") or name.endswith("_models.py"):
        return f"Modelo de dados para {name.replace('_model.py', '').replace('_models.py', '').replace('_', ' ')}"
    elif name.endswith("_schema.py") or name.endswith("_schemas.py"):
        return f"Schema de valida√ß√£o para {name.replace('_schema.py', '').replace('_schemas.py', '').replace('_', ' ')}"
    elif name.endswith("_test.py") or name.startswith("test_"):
        return f"Testes para {name.replace('_test.py', '').replace('test_', '').replace('_', ' ')}"
    elif name.endswith(".md"):
        return "Documenta√ß√£o"
    elif name.endswith(".json"):
        return "Arquivo de configura√ß√£o JSON"
    elif name.endswith(".yml") or name.endswith(".yaml"):
        return "Arquivo de configura√ß√£o YAML"
    elif name.endswith(".sql"):
        return "Script SQL"
    elif name.endswith(".sh"):
        return "Script Shell"
    elif name.endswith(".py"):
        return "M√≥dulo Python"
    
    return "Arquivo do projeto"

def generate_directory_documentation(directory: Path, output_file: Path, detailed: bool = False):
    """Gera documenta√ß√£o para um diret√≥rio espec√≠fico."""
    lines = []
    
    # Cabe√ßalho
    dir_name = directory.name
    relative_path = directory.relative_to(PROJECT_ROOT)
    
    lines.append(f"# Arquitetura - {dir_name}")
    lines.append(f"\n> Documenta√ß√£o da estrutura do diret√≥rio `{relative_path}`")
    lines.append(f"\n_√öltima atualiza√ß√£o: {datetime.now().strftime('%Y-%m-%d %H:%M')}_\n")
    
    # Descri√ß√£o do diret√≥rio
    description = KNOWN_DESCRIPTIONS.get(str(relative_path), "")
    if description:
        lines.append(f"## üìã Descri√ß√£o\n")
        lines.append(f"{description}\n")
    
    # Estrutura em √°rvore
    lines.append("## üå≥ Estrutura de Diret√≥rios\n")
    lines.append("```")
    tree_lines = get_tree_structure(directory, "", True)
    lines.extend(tree_lines)
    lines.append("```\n")
    
    # Tabela detalhada se solicitado
    if detailed:
        lines.append("## üìÅ Detalhamento dos Arquivos\n")
        lines.append("| Arquivo/Diret√≥rio | Tipo | Descri√ß√£o |")
        lines.append("|-------------------|------|-----------|")
        
        # Coleta todos os arquivos recursivamente
        for root, dirs, files in os.walk(directory):
            root_path = Path(root)
            
            # Remove diret√≥rios ignorados
            dirs[:] = [d for d in dirs if not should_ignore(root_path / d)]
            
            # Processa diret√≥rios
            for dir_name in sorted(dirs):
                dir_path = root_path / dir_name
                relative = dir_path.relative_to(directory)
                desc = KNOWN_DESCRIPTIONS.get(str(dir_path.relative_to(PROJECT_ROOT)), "Diret√≥rio do projeto")
                lines.append(f"| `{relative}/` | üìÅ Dir | {desc} |")
            
            # Processa arquivos
            for file_name in sorted(files):
                file_path = root_path / file_name
                if not should_ignore(file_path):
                    relative = file_path.relative_to(directory)
                    desc = get_file_description(file_path, directory)
                    icon = "üìÑ" if file_name.endswith('.py') else "üìã"
                    lines.append(f"| `{relative}` | {icon} | {desc} |")
        
        lines.append("")
    
    # Estat√≠sticas
    lines.append("## üìä Estat√≠sticas\n")
    
    # Conta arquivos e diret√≥rios
    total_files = 0
    total_dirs = 0
    file_types = {}
    
    for root, dirs, files in os.walk(directory):
        root_path = Path(root)
        dirs[:] = [d for d in dirs if not should_ignore(root_path / d)]
        
        total_dirs += len(dirs)
        
        for file in files:
            if not should_ignore(root_path / file):
                total_files += 1
                ext = Path(file).suffix.lower()
                file_types[ext] = file_types.get(ext, 0) + 1
    
    lines.append(f"- **Total de arquivos**: {total_files}")
    lines.append(f"- **Total de diret√≥rios**: {total_dirs}")
    lines.append(f"- **Tipos de arquivo**:")
    
    for ext, count in sorted(file_types.items(), key=lambda x: x[1], reverse=True):
        if ext:
            lines.append(f"  - `{ext}`: {count} arquivo(s)")
    
    lines.append("")
    
    # Salva o arquivo
    output_file.parent.mkdir(parents=True, exist_ok=True)
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    
    print(f"‚úÖ Gerado: {output_file}")

def generate_main_readme():
    """Gera o README principal da arquitetura."""
    output_file = ARCHITECTURE_DIR / "README.md"
    
    lines = []
    lines.append("# üèóÔ∏è Arquitetura do Projeto Hermes Panel Admin")
    lines.append("\n> Documenta√ß√£o completa da estrutura e arquitetura do projeto")
    lines.append(f"\n_√öltima atualiza√ß√£o: {datetime.now().strftime('%Y-%m-%d %H:%M')}_\n")
    
    lines.append("## üìö √çndice de Documenta√ß√£o\n")
    lines.append("Esta pasta cont√©m a documenta√ß√£o detalhada da arquitetura de cada m√≥dulo:\n")
    
    # Lista documenta√ß√µes dispon√≠veis
    docs = [
        ("app.md", "Arquitetura completa do backend"),
        ("frontend.md", "Estrutura do frontend React"),
        ("scripts.md", "Scripts utilit√°rios"),
        ("logs.md", "Sistema de logging"),
    ]
    
    for doc, desc in docs:
        lines.append(f"- [`{doc}`](./{doc}) - {desc}")
    
    lines.append("\n### üìÅ Documenta√ß√£o Detalhada dos M√≥dulos Core\n")
    
    core_modules = [
        ("app/aiagent", "Sistema de Agentes de IA"),
        ("app/core", "Funcionalidades Centrais"),
        ("app/api", "Configura√ß√£o da API"),
        ("app/auth", "Autentica√ß√£o e Autoriza√ß√£o"),
        ("app/db", "Camada de Dados"),
        ("app/domain", "Modelos de Dom√≠nio"),
        ("app/infrastructure", "Infraestrutura"),
        ("app/integrations", "Integra√ß√µes Externas"),
    ]
    
    for module, desc in core_modules:
        doc_name = module.replace('/', '_') + ".md"
        lines.append(f"- [`{doc_name}`](./{doc_name}) - {desc}")
    
    lines.append("\n## üîÑ Atualiza√ß√£o Autom√°tica\n")
    lines.append("Esta documenta√ß√£o √© mantida automaticamente por hooks do Claude Code.")
    lines.append("Sempre que novos arquivos ou diret√≥rios s√£o criados, a documenta√ß√£o √© atualizada.\n")
    
    lines.append("## üèõÔ∏è Vis√£o Geral da Arquitetura\n")
    lines.append("```")
    lines.append("hermespaneladm/")
    lines.append("‚îú‚îÄ‚îÄ app/              # Backend FastAPI")
    lines.append("‚îÇ   ‚îú‚îÄ‚îÄ aiagent/      # Sistema de IA")
    lines.append("‚îÇ   ‚îú‚îÄ‚îÄ core/         # N√∫cleo da aplica√ß√£o")
    lines.append("‚îÇ   ‚îú‚îÄ‚îÄ auth/         # Autentica√ß√£o")
    lines.append("‚îÇ   ‚îú‚îÄ‚îÄ integrations/ # APIs externas")
    lines.append("‚îÇ   ‚îî‚îÄ‚îÄ domain/       # Modelos de neg√≥cio")
    lines.append("‚îú‚îÄ‚îÄ frontend/         # Frontend React")
    lines.append("‚îú‚îÄ‚îÄ scripts/          # Scripts √∫teis")
    lines.append("‚îú‚îÄ‚îÄ architecture/     # Esta documenta√ß√£o")
    lines.append("‚îú‚îÄ‚îÄ hooks/            # Hooks Claude Code")
    lines.append("‚îî‚îÄ‚îÄ logs/             # Arquivos de log")
    lines.append("```")
    
    # Salva
    output_file.parent.mkdir(parents=True, exist_ok=True)
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    
    print(f"‚úÖ Gerado: {output_file}")

def main():
    """Fun√ß√£o principal do gerador."""
    print("üèóÔ∏è  Gerando documenta√ß√£o de arquitetura...")
    
    # Cria diret√≥rio de arquitetura
    ARCHITECTURE_DIR.mkdir(exist_ok=True)
    
    # Gera README principal
    generate_main_readme()
    
    # Gera documenta√ß√£o dos diret√≥rios principais (vis√£o geral)
    main_dirs = [
        (PROJECT_ROOT / "app", "app.md", False),
        (PROJECT_ROOT / "frontend", "frontend.md", False),
        (PROJECT_ROOT / "scripts", "scripts.md", False),
        (PROJECT_ROOT / "logs", "logs.md", False),
    ]
    
    for directory, filename, detailed in main_dirs:
        if directory.exists():
            output = ARCHITECTURE_DIR / filename
            generate_directory_documentation(directory, output, detailed)
    
    # Gera documenta√ß√£o detalhada dos m√≥dulos core
    detailed_modules = [
        (PROJECT_ROOT / "app" / "aiagent", True),
        (PROJECT_ROOT / "app" / "core", True),
        (PROJECT_ROOT / "app" / "api", True),
        (PROJECT_ROOT / "app" / "auth", True),
        (PROJECT_ROOT / "app" / "db", True),
        (PROJECT_ROOT / "app" / "domain", True),
        (PROJECT_ROOT / "app" / "infrastructure", True),
        (PROJECT_ROOT / "app" / "integrations", True),
    ]
    
    for directory, detailed in detailed_modules:
        if directory.exists():
            filename = str(directory.relative_to(PROJECT_ROOT)).replace('/', '_') + ".md"
            output = ARCHITECTURE_DIR / filename
            generate_directory_documentation(directory, output, detailed)
    
    print("\n‚ú® Documenta√ß√£o de arquitetura gerada com sucesso!")
    print(f"üìÅ Arquivos criados em: {ARCHITECTURE_DIR}")

if __name__ == "__main__":
    main()